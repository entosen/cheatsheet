# 設定

- `--global` をつけると、そのPC全体の設定。~/.gitconfig に書かれる。
- つけないとそのリポジトリだけの設定  リポジトリの .git/config に書かれる。

```
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
git config --global push.default simple

# pagerの設定
git config --global pager.branch false
git config --global pager.stash false
git config --global pager.config false
他にも pager.<cmd> の形で他コマンドについても指定できる

# windows でも今は(NTFSは)大文字小文字区別できるので、false にしておく。
# true だと、ファイル名の大文字小文字を変更したときに git にうまく伝わらない。
# global の方ではなく、リポジトリ毎の設定の方でこれが true にされているケースがある？
git config --global core.ignorecase false

# windows でも unix的改行コードが中心なので、以下を設定しておく。
git config --global core.eol lf 
git config --global core.autocrlf false

    core.autocrlf は、
	true: コミット時に CRLF→LF。チェックアウト時に LF→CRLF
	input: コミット時のみ CRLF→LF に変換 (Windowsのみtrueと同じ)
	false: 変換しない

# VBAコードなど windows関係のファイルだけからなるリポジトリの場合は
# 以下がよいと思う
git config core.eol crlf
git config core.autocrlf false   # 上でしていれば不要

# 日本語を含むファイル名を扱う場合、以下を入れないと git add などの表示で日本語が出ない
git config core.quotepath false

# 実行権限を正しく反映できないファイルシステムの場合は、false にする。
# falseの場合
#   checkout時、xビットはファイルシステムに反映しない。できない？
#     (内部の情報としては、xビットはきちんと保持されている。 git ls-files -s)
#   変更時、xビットの差分に関しては、差分とみなさない。
#   新規add時、xビットはoffにして登録される
# 通常は git clone 時に判定され適切にセットされる。
git config core.filemode false
```



確認 

```
git config --list
```

参考 - <cite>[Git - 最初のGitの構成](https://git-scm.com/book/ja/v1/%E4%BD%BF%E3%81%84%E5%A7%8B%E3%82%81%E3%82%8B-%E6%9C%80%E5%88%9D%E3%81%AEGit%E3%81%AE%E6%A7%8B%E6%88%90 "Git - 最初のGitの構成")</cite>


## メールアドレスを非公開にしてgit,githubで活動する方法

<cite>[Keeping your email address private - User Documentation](https://help.github.com/articles/keeping-your-email-address-private/ "Keeping your email address private - User Documentation")</cite>

- github の Settings > Emails > Keep my email address private. にする。
- git の user.emailの設定を、`<username>@users.noreply.github.com` を使う。



## リポジトリに寄らず効く .gitignore 関係

vimの swap ファイルなどは、リポジトリの .gitignore に入れるより、
その環境として無視設定しておく方がいい。
(誰がどのエディタで編集して、どういう一時ファイルができるかは読み切れないので、
リポジトリではなく編集する人の側で責任を持つ)

> Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary
> files generated by the user’s editor of choice) generally go into a file specified by
> core.excludesFile in the user’s ~/.gitconfig. Its default value is
> $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty,
> $HOME/.config/git/ignore is used instead.

上記のようにあるので、`$HOME/.config/git/ignore` に以下のように設定する。

```
*.sw?
*.pyc
```

ネット検索すると `~/.gitconfig` に `excludesfile = ~/.gitignore` とするという記事が結構見つかるが、
上記方法の方が、デフォルトっぽくてよいと思う。


# リポジトリを作る

## 既にあるリポジトリをcloneしてくる

## 新たに作ったプロジェクトを github に登録する

```
$ git init
$ git add .
$ git commit -m "Initial commit"
$ git remote add origin git@github.com:myname/hogehoge.git   # <-- 適切に変える
$ git push origin master
```

## 新たに作ったプロジェクトを github に登録する (IntelliJ版)

- IntelliJ で新規プロジェクトを開始。
- ファイルを追加
- メニュー ＞ VCS ＞ Enable Version Control Integration...
  - Git を選択 
  - (git init相当の処理が行われているはず)
  - (ホームディレクトリの IdeaProject 以下のPJフォルダが、git管理下になっている)
- 必要なら git config で設定を行う (user.name, user.emailをリポジトリごとに返る場合など)
- .gitignore を作成
- ここまでやると、IntelliJ の "Version Control" タブに "Unversioned Files" として作ったファイルが出てきているはずなので、"Default" に移す。
- IntelliJ からコミット (ローカルリポジトリにコミットされる)

この時点では
```
> git branch -avv
* master 4ea4f36 ログメッセージほげほげほげ

> git remote -v 
(何も出ない)
```

- github の UIからリポジトリを作成しておく
- `git remote add origin git@github.com:__USERNAME__/__REPOSITORY__.git`
これでいいのか？社内からだと github に SSHアクセスできないので、https://github の形式にしないとだめかも。

- git push 
fast-forward updateじゃないのでrejectされちゃう。

- git fetch
- git merge ごにょごにょ
- git push







# 典型的な開発のときのコマンド

TODO

# add, commit 関係

```
git add ファイル名...    # ファイル指定で add

git add -u    # 既に管理対象、かつ、変更があったファイルをaddする。
```

# diff

```
git diff   # index に add していないモノを表示 (index->WorkTree)
git diff --cached    # 次の commit で反映される変更を表示 ( HEAD->index)
git diff HEAD^ HEAD  # 直前の commit による変更を表示
git diff HEAD^ HEAD --stat
```

# ブランチ関係 ( branch, checkout, push, pull, merge )

まずは確認の方法

```
git branch -avv
```

## リモートの別ブランチをチェックアウトする

```
git checkout -b other_branch origin/other_branch

もしくは (要確認)
git branch other_branch origin/other_branch
git checkout other_branch
```

自動で upstream は設定されたはず。(要確認)

## github の PR のブランチをチェックアウトする

github上の自分のリポジトリを誰かがforkしてPRを送ってきた場合、
PRの動作確認をするためにそのブランチをチェックアウトしたいときがある。

しかし、その場合、自分リポジトリ内ではないので、git fetch では取ってこれない。

真面目にやると、remote設定して、fetchして、checkoutして、となるが、
以下の方法で簡単にできる。

- [Checking out pull requests locally - GitHub Help](https://help.github.com/en/articles/checking-out-pull-requests-locally)

```
git fetch origin pull/${ID}/head:${BRANCHNAME}
git checkout ${BRANCHNAME}
```

- IDは、PRのID
- BRANCHNAME は、ローカルのブランチになるので、お好みで。
　PR-123 みたいな感じがいい。


## ローカルで新しいブランチを作る

```
git branch 新ブランチ名
git checkout 新ブランチ名
```

## push

編集して、addとか commit とかしたら push する。

最初の一度だけ(upstreamが設定されていないときだけ)、明示的に上げ先の指定が必要。

```
git push --set-upstream origin 新ブランチ名
もしくは
git push -u origin 新ブランチ名
```

`--set-upstream`, `-u` オプションをつけておくと、upstream 設定もされる。

upstreamがされている、されていないの違いは以下で確認できる
```
git branch -avv

されていない
* jikken1 7280884 Add jikken programs.
  master  f465c57 [origin/master] Initial commit
されている
* jikken1                7280884 [origin/jikken1] Add jikken programs.
  master                 f465c57 [origin/master] Initial commit
```

もし、既にpushしてしまって、upstreamの設定だけしたい場合は、

```
git branch --set-upstream-to origin/新ブランチ名
```

## merge, fetch, pull

```
# issue1 の変更 を master にマージする場合。
git checkout master
git merge issue1
```

```
git pull 
```




## ブランチを消す

```
git branch -d 消したいブランチ

リモートで消されたブランチはローカル(の remotes/origin/～ )には残り続ける。
それを消すには -p オプション をつける。 
git fetch -p 
```


## rebase

今いるブランチの変更点を、新しいポイントから生やし直す、みたいな感じ。

```
git rebase [--onto 接続先] [切り取り開始点 [切り取り終了点]]
git rebase [--onto <newbase>] [<upstream> [<branch>]]
```

- 対象ブランチ、切り取り終了点 branch --- rebase で生やし直すブランチ。省略した場合はカレントブランチ。
- 切り取り開始点 upstream --- 切り取りの開始点となるブランチ。 省略時は branch の上流ブランチ。
- 接続先 newbase --- 新しくブランチを生やす起点。省略した場合は upstream 。


差分コミット(便宜上)

- 切り取り終了点の履歴に含まれているが、切り取り開始点の履歴に含まれていないコミット群


ながれ。

- (カレントブランチを対象ブランチにスイッチ)
- 差分コミットを求め覚えておく
- 対象ブランチを一旦破棄、接続先から新たに分岐
- 差分コミットを1つずつ順番にコミットしてブランチを伸ばしていく

```
      A---B---C topic
     /
D---E---F---G master

              A'--B'--C' topic
             /
D---E---F---G master

git rebase master
git rebase master topic
git rebase --onto master master topic
```

```
o---o---o---o---o  master
     \
      o---o---o---o---o  next
                       \
                        o---o---o  topic


o---o---o---o---o  master
    |            \
    |             o'--o'--o'  topic
     \
      o---o---o---o---o  next


git rebase --onto master next topic

---
                        H---I---J topicB
                       /
              E---F---G  topicA
             /
A---B---C---D  master

             H'--I'--J'  topicB
            /
            | E---F---G  topicA
            |/
A---B---C---D  master

git rebase --onto master topicA topicB
```

ある特定のコミットを消すようにも使える。
```
E---F---G---H---I---J  topicA

E---H'---I'---J'  topicA

git rebase --onto topicA~5 topicA~3 topicA
```







参考

- [Git - git-rebase Documentation](https://git-scm.com/docs/git-rebase)
- [git-rebase – Git コマンドリファレンス（日本語版）](https://tracpath.com/docs/git-rebase/)
- [git rebase の動作を --onto 指定も含めて正しく理解する - Qiita](https://qiita.com/hkuno/items/ef639b75efc156cf37d7)




# ファイル名の変更・移動

```
git mv oldfile newfile   # ファイル名の変更
```


# remote

リモートリポジトリを管理する - GitHub Docs
https://docs.github.com/ja/github/getting-started-with-github/getting-started-with-git/managing-remote-repositories

複数の remote をあつかう。
```
git remote -v   # 確認
git remote add remoteName remoteUrl
git remote -v   # 確認
```

remote の向き先を変えたくなった場合、
(例えば、github の https プロトコルで clone/push していたものを、sshでのプロトコルに変更する)

```
git remote set-url origin git@github.com:USERNAME/REPOSITORY.git
```


プロトコル

- Git - プロトコル
https://git-scm.com/book/ja/v2/Git%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC-%E3%83%97%E3%83%AD%E3%83%88%E3%82%B3%E3%83%AB
- 個人アクセストークンを使用する - GitHub Docs
https://docs.github.com/ja/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token


Localプロトコル(同じディスク上。ディレクトリのコピーみたいな感じ)
```
git clone /opt/git/project.git
git clone file:///opt/git/project.git
```
HTTPプロトコル(認証が要求されるのは必要なときだけ。その場合アクセストークンでの認証。)
```
git clone https://example.com/gitproject.git
```
SSHプロトコル(接続のために認証が必要)
```
git clone ssh://user@server/project.git
git clone user@server:project.git
```
gitプロトコル(9418番ポート。読み込みのみ？)
```
git://servername.com/hogerepo/repo.git
```

(Tips) github には、443番ポート(https用のポート)で、ssh プロトコルを待ち受けているホストがある。
ssh.github.com 。
ここを使えば、22番ポート(ssh用のポート)がファイアーウォールで閉じられている場合でも、
443番ポートを通ってssh通信でclone/pushができる。

ssh の config に下記のように設定
```
Host github.com
  HostName ssh.github.com
  User git
  Port 443
```

HTTPS ポートを介して SSH を使用する - GitHub Docs
https://docs.github.com/ja/github/authenticating-to-github/troubleshooting-ssh/using-ssh-over-the-https-port

(Tips) sshポートをテストする
```
ssh -T git@github.com

下記が返ってくればOK
> Hi username! You've successfully authenticated, but GitHub does not
> provide shell access.

443番ポートなら通るかを確認する
ssh -T -p 443 git@ssh.github.com
```

ssh用の秘密鍵/公開鍵の作り方例
```
ACCOUNT=自分のgitアカウントを入れる。
ssh-keygen -t ed25519 -f ~/etc/key/${ACCOUNT}_github_com-$(date '+%Y-%m-%d') -C "${ACCOUNT}@github.com - $(date '+%Y-%m-%d')"
```

# .gitignore

## .gitignore の仕様

> [Git] .gitignoreの仕様詳解 - Qiita
> http://qiita.com/anqooqie/items/110957797b3d5280c44f

```
/を含まない行（fileなど）
    .gitignore以下の全サブディレクトリ下にあるこの名前のファイル or ディレクトリを無視する
末尾だけ/な行（directory/など）
    .gitignore以下の全サブディレクトリ下にあるこの名前のディレクトリを無視する
末尾以外にのみ/を含む行（/file, /path/to/file, path/to/fileなど）
    .gitignoreが置いてあるディレクトリをカレントディレクトリとする相対パス(*1)で指定されるファイル or ディレクトリを無視する
    先頭の/はルートを意味せず単に無視される
末尾以外にも末尾にも/を含む行（/directory/, /path/to/directory/, path/to/directory/など）
    .gitignoreが置いてあるディレクトリをカレントディレクトリとする相対パス(*1)で指定されるディレクトリを無視する
    先頭の/はルートを意味せず単に無視される
!で始まる行（!/path/to/fileなど）
    !以降のパターン文字列が示すファイル or ディレクトリを無視しない
    前の無視指定を上書きする
    以降の無視指定に上書きされうる
空行 or #で始まる行
    解釈されない 
```

(*1) ~/.config/git/ignore など、.gitignore 以外のファイルに書かれたパターンの場合は、ワークツリーのトップからの相対パス

除外(git-2.7以降)
```
/.idea
!/.idea/codeStyleSettings.xml
```


## サンプル

### scala,sbt とか

```
*.class
*.log

# sbt specific
.cache
.history
.lib/
dist/*
target/
lib_managed/
src_managed/
project/boot/
project/plugins/project/

# Scala-IDE specific
.scala_dependencies
.worksheet

# InteliJ specific
/.idea/*
!/.idea/codeStyleSettings.xml
```


# 本家をforkしたリポジトリで、本家に追従しながら開発

以下の三角関係を頭に入れておく

- 本家リポジトリ (リモート。例えばgithub上)
- 俺リポジトリ (リモート。例えばgithub上。本家リポジトリをforkしてできた)
- ローカルリポジトリ (ローカル。俺リポジトリを git clone)

```
github の UI上から本家リポジトリをforkして、俺リポジトリを作る

# 俺リポジトリをローカルに git clone
git clone <俺リポジトリのURL>

    # 確認
    git branch -avv 
      master                      ...[origin/master]...   # ローカル
      remotes/origin/master                               # 俺リポジトリ

    git remote -v
    origin  https://github.com/myrepo/foo.git (fetch)    # 俺リポジトリ
    origin  https://github.com/myrepo/foo.git (push)

# 本家リポジトリを git remote add。 upstreamという名前が一般的らしい
git remote add upstream https://github.com/origrepo/foo.git

    # 確認
    git remote -v
    origin  https://github.com/myrepo/foo.git (fetch)        # 俺リポジトリ
    origin  https://github.com/myrepo/foo.git (push)
    upstream        https://github.com/origrepo/foo.git (fetch)   # 本家リポジトリ
    upstream        https://github.com/origrepo/foo.git (push)

# 本家リポジトリを fetch
git fetch upstream

    # 確認
    git branch -avv 
      master                     ...[origin/master]...   # ローカル
      remotes/origin/master                              # 俺リポジトリ
      remotes/upstream/master                            # 本家リポジトリ

# 本家リポジトリの変更をローカルにマージ
git merge upstream/master

# 更にそれを俺リポジトリにpush
git push
```


# 間違えた系

- [Backlinks for: git/コミットログを修正する方法 - TOBY SOFT wiki](http://tobysoft.net/wiki/index.php?plugin=related&amp;page=git%2F%A5%B3%A5%DF%A5%C3%A5%C8%A5%ED%A5%B0%A4%F2%BD%A4%C0%B5%A4%B9%A4%EB%CA%FD%CB%A1)

```
// 直前のコミットのメッセージを直したい。
git commit --amend -m "新しいメッセージ"
```


```
// add する前の変更を元に戻したい
git checkout <file>...


// いらないファイルをaddしてしまった。取り消したい。
// 更新でも、新規で追加したファイルでもOK。
git reset HEAD <file>...


// まちがったcommitをしてしまった。このブランチにコミットしたかったんじゃない
// 直前にした commit を取り消す。
//     HEAD^ はひとつ前のコミットの意味
//     --soft は、ワークディレクトリの内容はそのまま。
//            つまりreset後、git的には未ステージの変更あり状態になる
git reset --soft HEAD^
```



# 以下、未整理。

### stash

参考
- [Git - 作業を隠す](https://git-scm.com/book/ja/v1/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E4%BD%9C%E6%A5%AD%E3%82%92%E9%9A%A0%E3%81%99)

```
# スタックに隠す(積む)。ステージ(git add)されている変更も含まれる
git stash       # staged と unstaged がスタッシュされる。 unstacked ファイルはされない。

git stash save <コメント>    # コメントをつけられる

git stash -k    # unstaged ファイルのみをスタッシュ (--keep-index)
git stash -u    # unstack ファイルも含めてスタッシュ (--include-untracked)

# 一覧表示
git stash list [<options>]     # options には git log で使えるものが指定できる
git stash list --stat          # ファイル名と変更行数(棒グラフみたいなので)
git stash list --numstat       # ファイル名と変更行数(数値で)
git stash list --name-status   # ファイル名とステータス (Mとか)
git stash list -p              # diffも表示する

# 戻す
git stash apply              # 最近の
git stash apply stash@{2}    # 指定

# ファイル変更を戻すだけでなく、以前のステージ状態も戻す
git stash apply --index

# スタックから削除
git stash drop                # 最近の
git stash drop statsh@{0}     # 指定
git stash clear               # 全部

# スタック適用と削除を同時に
git stash pop

# 内容表示
git stash show [<stash>]   # 変更したファイル名の表示。statsh 名を省略した場合は最新の。
git stash show -p [<stash>]   # 変更内容のdiff表示。statsh 名を省略した場合は最新の。

# 積んだ差分を確認する
git diff HEAD..stash@{0}
```


### worktree

1つのローカルリポジトリで、作業ツリーを複数同時に持てる。

同じリポジトリに対し、複数の作業を同時にやる(開発と他の人のレビューとか)場合に便利。

前提として、自分の場合、下記のようなディレクトリ構造にする
```
workgit/repoA/
    repoA/          --- clone してきたローカルリポジトリ本体ディレクトリ
    worktree/
        review/     --- 他の人のレビュー用に使う追加のワークツリー
        hoge/       --- その他、必要であればこんな感じで
        fuga/
```

```
git worktree add [-b <new_branch>] <path> [<commit-ish>]

例
git worktree add ../worktree/docs
    今いる位置を、新しく docs ブランチとして、 ../worktree/docs にワークツリーを追加する

git worktree add ../worktree/feature1 feature1
    既存の feature1 ブランチを ../worktree/feature1 にワークツリーとして追加する
```


不要になったワークツリーを消す

```
git worktree remove <ワークツリーのパス>
```


# github 検索

```
user:
filename:
```




cygwinなど、パーミッションを適切に扱えない環境から、パーミッションを操作する

```
git update-index --chmod=-x path/to/file
git update-index --chmod=+x path/to/file
```

# github 特有




# submodule


```
git submodule add <リポジトリ>
```

- submoduleの情報は .gitmodule ファイルに格納される。 このファイルも git 管理下に入ります。
- sbumoduleのディレクトリも git 管理下に入ります。

参考
- Git - サブモジュール
https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E3%82%B5%E3%83%96%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB



# git LFS

gitが苦手な大きなバイナリファイルを扱うための仕組み。

git は、分散SCMなので、cloneすると全履歴のスナップショットを取得する。
大きなバイナリファイルをgit管理にしておくと clone の際に大量のファイルのダウンロードが必要になってしまう。

それを解決するために git LFS では、LFSで管理することにしたファイルは、下記のように扱われる。

- ファイルの実体は別のサーバ(LFSサーバ)に上げる
- git では、ファイルへのポインタとハッシュ値だけを管理する
- git clone・git pullのときではなく、git checkoutのタイミングで必要な分だけダウンロードされる


参考

- [Git Large File Storage](https://git-lfs.com/)





インストール

```
# mac
brew update
brew install git-lfs

git lfs install 
    → ユーザーグローバルの ~/.gitconfig に設定が追加される
    → (リポジトリ内でやった場合) リポジトリに pre-push hook を追加する
```

以下は、各リポジトリで。


すでにLFS管理になっているリポジトリをcloneしてくる場合
```
git clone <リポジトリ>     # 普通にcloneすればOK。
```

自分が新規に作る場合
```
# 普通にリポジトリを準備
git init                 # 新規リポジトリを作成する場合
git clone <リポジトリ>   # LFS未管理のリポジトリをcloneする場合

git lfs install
    → これで .git/hooks/ 以下にいくつかのフックが追加される
```



追跡ファイルパターン

これはリポジトリの .gitattributes に保存される。 .gitattributesファイルはgit管理する。

```
git lfs track     # 追跡ファイルパターンのリスト

git lfs track [<パターン>...]   # 追跡パターンの追加

    --lockable


git lfs untrack [<パターン>...]   # 追跡パターンの削除
```


LFS管理ファイルの上げ先のサーバ。 これは、.lfsconfig に記載される。このファイルもgit管理する。
```
git config -f .lfsconfig --list    # 確認

git config -f .lfsconfig lfs.url https://foo.backlog.com/git/BAR/baz.git/info/lfs   # セット例
```


```
git lfs lock foo/bar/example.png
git lfs locks      # ロック中のファイル一覧
git lfs unlock foo/bar/example.png
```




## 既にgit管理下にあるファイルへの変更をgitに無視させる


無視させたいファイルが、git管理下にない(untracked)な場合、.gitignore で除外させる。

無視させたいファイルが、既にgit管理下にある場合、下記の方法でgitに差分を無視させる。

```
git update-index --skip-worktree <path>      # フラグ付ける
git update-index --no-skip-worktree <path>   # フラグ外す
git ls-files -v | grep ^S                    # 確認
```

このフラグを付けると、ローカルで編集してもgitは編集がないものとして扱ってくれる。

ただし、リポジトリ側でそのファイルが更新された場合、
つまり、git merge や git checkout でそのファイルにリポジトリ側の変更を反映しようとするとエラーになる。
つまり、自動でマージはしてくれない。

その場合、下記のような手順になる

- 一旦 ``--no-skip-worktree`` 
- git stash などで適切に退避
- git merge など
- git stash pop でローカル変更を戻す
- 再度 ``--skip-worktree``


