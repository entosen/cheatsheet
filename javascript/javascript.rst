############################################
JavaScript (基本)
############################################

******************************************
最初に
******************************************

コメント

TODO


出力

::

    console.log(mesg)
    console.info(mesg)
    console.warn(mesg)
    console.error(mesg)

    console.dir
    console.time
    console.timeEnd

    log(obj1)
    log(obj1, /* …, */ objN)
    log(msg)
    log(msg, subst1, /* …, */ substN)


::

    "use strict";
    'use strict';




******************************************
変数、定数、リテラル、データ型
******************************************

::

    let, var, const   // 宣言

    const --- 初期化後に値を変更できない。


    TODO var と let の違いの理解があやしい。for(let i=0;...) とした場合とか。


    識別子
    1文字目: 英文字、_、$
    2文字目: 英文字、数字、_、$

    その他ユニコードで日本語なども使える

    大文字小文字は区別される

    一般的には camel case : anIdentifierName


    値


    プリミティブ型とオブジェクト

    プリミティブ型

            * 不変、immutable
            * 6つ
                    * 数値(Number)
                    * 文字列(String)
                    * 論理値(Boolean)
                    * null
                    * undefined


    オブジェクト

            * 配列（Array）
            * 日時（Date）
            * 正規表現（RegExp）
            * マップ（Map）とウィークマップ（WeakMap）
            * セット（Set）とウィークセット（WeakSet）





    数値
    倍精度浮動小数点数の表現（64ビット）

    数値リテラル

    // 10進数
    10, 21.5, 3.0e6, -1.6e-19
    // 16進数, 8進数, 2進数
    0xff, 0o22, 0b0101
     
    Infinity    (1/0)
     -Infinity   (-1/0)
    Nan   (Infinity/Infinity)


    文字列

    シングルクォートで囲む、ダブルクォートで囲む、どちらを使っても違いはない

    テンプレートリテラル バッククォートで囲む
    ${...} の中が式として解釈される。 $そのものを表示したいときはエスケープする。
    `現在の温度は${currentTemp}℃です。`

    エスケープ


    数値と文字列の自動変換 TODO
    3 + '30'; // 3は文字列に変換され、結果は文字列の'330'になる
    3 * '30'; // '30'は数値に変換され、結果は数値の90になる



    論理値
    true, false

    シンボル
    TODO


    Date型
        new Date()
        strftime パッケージ




オブジェクト
===========================

オブジェクトはプロパティの集合。プロパティは名前(キー)と値(バリュー)が対になったもの。

- キーは、文字列または Symbol。

  - それ以外、数値とかを入れると暗黙的に文字列に変換される
  - cf. Map はオブジェクトをキーとして扱える

- 値は、任意のデータ型

オブジェクト型は、変数には参照が入る。オブジェクト型は Mutable。 
なので、const 変数に入れても参照を変えられないだけで、オブジェクトの中身を変更することは可能。
変更させたくない場合は ``Object.freeze`` を使う。

作成::

    // オブジェクトリテラル
    const obj = {             
        "key1": "value1",     // キーを文字列で指定

        key2: value2,         // 識別子として許される名前であれば、クオートを省略できる。
                              // "key2": value2 と同義。 
                              // (注)キーは変数展開されない。
                              //     もし既に key2 という変数があったとしてもそれとは別個。
                              // cf. 値は変数展開される。式として評価される。

        [key3]: "value3",     // こうも書けるらしい。(ES2015〜) Computed property names 。
                              // この場合 [] の中は式として評価される。変数展開される。

        value3,               // "value3": value3 と同じ意味。(ES2015〜)


        // TODO Symbol

        123: 456,             // キーは暗黙的に文字列に変換され "123": 456

        func1() {             // TODO 関数型の値をセットする場合の特殊な書き方
            ...
        }

        ...otherObj           // spread構文 (ES2018〜)。 他のオブジェクトの各 key:value をこの位置に展開。
                              // もし名前が重複したら、後ろ優先

        // ECMASCript 5 から末尾カンマ可
    };
    
    
    {};               // 空オブジェクト
    new Object():     // 空オブジェクト。
                      // Objectのインスタンスオブジェクトを作っているらしい。？？？まだ意味わからん


プロパティの参照::

    obj.key           // キーが命名規則を満たしている場合、ドット記法で書ける。 obj["key"] と同義。

    obj["key"]        // ブラケット記法
    obj[myLang]       // []の中は任意の式が書ける。この場合、myLangの中身の文字列を名前として参照する。
    obj[123]          // キーは暗黙的に文字列に変換される。 obj["123"]


    存在しないプロパティへのアクセスは、 undefined が返る (例外にはならない)
    cf. undefined をさらにドットアクセスしたら例外になる
        (例) TypeError: widget.window is undefined

    obj?.a?.b
        Optional chaining、オプショナル・チェイニング、 ?.  (ES2020〜)
        左辺が nullish (null または undefined) の場合は、それ以上評価せずに undefined を返す。
        それ以外は、ドットアクセスした結果を返す
        (例)
            widget?.window?.title ?? "未定義"

    obj?.[myKey1]?.[myKey2]
        Optional chaining ブラケット記法版。[]の中は式として評価される。




プロパティの存在確認::

    if (obj.key !== undefined) {...}   // これが成り立つのは、下記2つのケースがある
                                       //   - キー"key"がない場合
                                       //   - キー"key"があり、値が undefined 値の場合

    if ("key" in obj) {...}               // キーが存在すれば True
    if (Object.hasOwn(obj, "key") {...}   // キーが存在すれば True (ES2022〜)
    if (obj.hasOwnProperty("key")) {...}  // キーが存在すれば True   (欠点があるらしい)
                                          // この辺はプロトタイプオブジェクトまわりで微妙に違うらしい


プロパティの追加・変更::

    obj.key = "value"
    obj["key"] = "value"   // []内は式として評価される

プロパティの削除::

    delete obj.key1;

    // TODO もっと深い階層も書けるんだろうか？


ループ::

    const obj = {"one": 1, "two": 2, "three": 3};

    Object.keys(obj);     // => ["one", "two", "three"]
    Object.values(obj);   // => [1, 2, 3]
    Object.entries(obj);  // => [["one", 1], ["two", 2], ["three", 3]];

キーの順序は保証されないと思っておくこと。(条件によっては特定の順番になることもある)
(cf. Map型は挿入順で保証される)

- `[JavaScript] オブジェクト/Mapのキーの列挙順は保証されるのか - Qiita <https://qiita.com/anqooqie/items/ab3fed5d269d278cdd2b>`__


マージと複製::

    ただの代入は、参照だけのコピー。同じオブジェクトを指している。

    下記の方法は、浅いコピー。別なオブジェクトになるが、値がオブジェクトの箇所は同じ参照を指すまま。

    Object.assign(target, ...sources);
        第1引数のオブジェクトに、第2引数以降のオブジェクトの内容をマージする。
        (つまり第1引数には副作用がある)
        返り値は、第1引数のオブジェクトを返す。

        名前が重複した場合は、後ろ優先。

    const objectA = { a: "a" };
    const objectB = { b: "b" };  
    const merged = Object.assign({}, objectA, objectB);  // 副作用させたくない場合は{}を指定すればよい
        // => {a: "a", b: "b"}


    // オブジェクトリテラル内のspread構文 (ES2018〜)
    const objectA = { a: "a" };
    const objectB = { b: "b" };
    const merged = {
        ...objectA,
        ...objectB
    };
        // => { a: "a", b: "b" }
        // この場合も名前が重複した場合は、後ろ優先。


    複製 (浅い複製)
    const obj2 = Object.assign({}, obj)


TODO オブジェクトの比較は？

オブジェクトの分割代入 (ES2015〜)
-----------------------------------------

分割代入 (Destructuring assignment)

オブジェクトからプロパティを取り出して別個の変数に代入する。

::

    const obj = {id: 42, isVerified: true};

    // 宣言と同時に代入する場合
    const {id, isVerified} = obj;    // const id = obj.id
                                     // const isVerified = obj.isVerified

    // 宣言を別でやる場合
    // 丸かっこで囲む必要がある。ブロックではなく式として認識させるため。
    // ( ... ) の式の前にセミコロンが必要。じゃないと、前の行の関数呼び出しになる可能性
    const id, isVerified;
    ({id, isVerified} = obj);

左辺はオブジェクトリテラルに似ているが、微妙に違う::

    key: var

- キー部分は、オブジェクトのどのキーを取ってくるかを指定する。オブジェクトリテラルと同じっぽい。
- 値部分は、代入先を指定する。また規定値の指定も可能。

キー部分::

    {
        "key1": var1,     // var1 = obj["key1"] 
        key2: var2,       // var2 = obj["key2"]。キーが識別子として有効な形ならクオート不要。
        [式]: var3,       // 計算されたプロパティ名。[]内は式として評価される
        key4,             // "key4": key4 と同義。つまり key4 = obj["key4"]。よく登場する。

        ...rest           // 残余プロパティ (まだ提案中)
                          // 分割パターンによってすでに取り出されていない、残りの列挙可能なプロパティが
                          // オブジェクトの形で代入される。
    } = obj


規定値

オブジェクトから取り出した値が undefined (キーなしも含む)だったときの、規定値を指定できる::

    {
        "key1": var1 = 10,
        key2: var2 = 10,
        key3 = 10,
    }

規定値なしで、objにキーがなかった場合、変数は undefined になる。


深い階層。入れ子。 ::

    const user = {
      id: 42,
      displayName: 'jdoe',
      fullName: {
        firstName: 'John',
        lastName: 'Doe'
      }
    };

    const {displayName, fullName: {firstName: name}} = user;
        // displayName = 'jdoe'
        // firstName = 'John'


使いどころ

- 関数の引数
- イテレーターの一時変数







******************************************
制御フロー
******************************************

TODO

::

    list.forEach(cb)
    list.filter(cb)


- 三項演算子
- Nullish coalescing演算子 (``??``)


******************************************
式と演算子
******************************************

******************************************
関数
******************************************


関数
---------

TODO::

    関数の定義と無名関数の定義。
        funcition (res) {...}
        (res) => {...}



アロー関数::

    (param1, param2, …, paramN) => { statements } 
    (param1, param2, …, paramN) => expression
    // 上記の式は、次の式と同等です: => { return expression; }

    // 引数が 1 つしかない場合、丸括弧 () の使用は任意です:
    (singleParam) => { statements }
    singleParam => { statements }

    // 引数がない場合、丸括弧を書かねばいけません:
    () => { statements }



TODO

await
async
Promise

******************************************
スコープ
******************************************

******************************************
配列
******************************************

************************************************
オブジェクトとオブジェクト指向プログラミング
************************************************

******************************************
MapとSet
******************************************

******************************************
例外とエラー処理
******************************************

******************************************
イテレータとジェネレータ
******************************************

******************************************
非同期プログラミング
******************************************

- callback
- Promiseオブジェクト

    - メソッド (then, catch)
    - async/await    Promiseオブジェクトによる非同期処理を同期的に記述できる(ES2017～)

      - → サンプルコードあったけど、むずいな。。。

TODO Reactorパターン

******************************************
日時
******************************************

******************************************
Math
******************************************

******************************************
正規表現
******************************************

::

    if (/^\/api\/parsetime/.test(req.url)) {...}

